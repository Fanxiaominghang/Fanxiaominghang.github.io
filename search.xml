<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux驱动开发-概述</title>
    <url>/2025/02/15/Linux-driver/0-Linux%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\some\place\APlayer.min.css"><script src="http://xxx/aplayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\some\place\Meting.min.js"></script><h2 id="Linux驱动开发"><a href="#Linux驱动开发" class="headerlink" title="Linux驱动开发"></a>Linux驱动开发</h2><p>Linux驱动如何学习和理解，借用大神总结的话，在此记录下，我初次看时感觉很受用，理解的很到位：</p>
<p>上层是文件系统和应用，中层是Linux内核，下层是底层硬件，Linux驱动是介于文件系统和底层硬件之间的，是嵌入到内核中的程序，应用是嵌入到文件系统中的程序，比如Android APP。</p>
<p>对上：Linux设备驱动给上层提供调用的接口；</p>
<p>对中：Linux设备驱动要注册到内核中，标准说法是 挂载在总线上；</p>
<p>对下：直接操作硬件，如GPIO、IIC、SPI、PWM等；</p>
<p>以上三个，Linux内核都提供了大量的接口函数、结构体，其实Linux驱动，就是掌握了这些东西怎么用，适应到自己要写的驱动程序中。</p>
<h2 id="Linux代码风格"><a href="#Linux代码风格" class="headerlink" title="Linux代码风格"></a>Linux代码风格</h2><p>Linux 内核中处处体现面向对象的设计思想，为了统一形形色色的设备，Linux 系统将设备分别抽象为struct cdev, struct、block_device,struct net_devce 三个对象，具体的设备都可以包含着三种对象从而继承和三种对象属性和操作，并通过各自的对象添加到相应的驱动模型中，从而进行统一的管理和操作。</p>
<h2 id="Linux字符设备"><a href="#Linux字符设备" class="headerlink" title="Linux字符设备"></a>Linux字符设备</h2><p>Linux 内核中将字符设备抽象成一个具体的数据结构(struct cdev), 我们可以理解为字符设备对象，cdev 记录了字符设备的相关信息(设备号、内核对象)，字符设备的打开、读写、关闭等操作接口(file_operations)，在我们想要添加一个字符设备时，就是将这个对象注册到内核中，通过创建一个文件(设备节点) 绑定对象的cdev，当我们对这个文件进行读写操作时，就可以通过虚拟文件系统，在内核中找到这个对象及其操作接口，从而控制设备。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>1-Linux系统基本操作</title>
    <url>/2025/02/17/Linux-driver/1-Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\some\place\APlayer.min.css"><script src="http://xxx/aplayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\some\place\Meting.min.js"></script><h1 id="一-linux内核"><a href="#一-linux内核" class="headerlink" title="一.linux内核"></a>一.linux内核</h1><h2 id="1-啥是内核"><a href="#1-啥是内核" class="headerlink" title="1.啥是内核"></a>1.啥是内核</h2><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725204524887.png" alt="image-20240725204524887"></p>
<p>内核约等于操作寄存器，但是内核不能被用户直接操作，而是要通过调用</p>
<h2 id="2-内核下载"><a href="#2-内核下载" class="headerlink" title="2.内核下载"></a>2.内核下载</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725204737104.png" alt="image-20240725204737104"></h2><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725205015723.png" alt="image-20240725205015723"></p>
<p>谁都能用内核源码封装一个操作系统</p>
<h2 id="3-远程连接"><a href="#3-远程连接" class="headerlink" title="3.远程连接"></a>3.远程连接</h2><p>finalshell -&gt;ssh -&gt;ip地址</p>
<p>wsl</p>
<h1 id="二-基础命令"><a href="#二-基础命令" class="headerlink" title="二.基础命令"></a>二.基础命令</h1><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725213218690.png" alt="image-20240725213218690"></p>
<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>默认打开home</p>
<p>ls -ahl &#x2F;</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>默认进去home目录</p>
<p>注意相对绝对路径</p>
<p>可以使用特殊路径符</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725214818087.png" alt="image-20240725214818087"></p>
<h3 id="pwd（print-work-directory）"><a href="#pwd（print-work-directory）" class="headerlink" title="pwd（print work directory）"></a>pwd（print work directory）</h3><p>查看当前目录</p>
<h3 id="mkdir（make-directory）"><a href="#mkdir（make-directory）" class="headerlink" title="mkdir（make directory）"></a>mkdir（make directory）</h3><p>新建目录</p>
<p>mkdir -p 路径 	一次性创建多层目录</p>
<p>注：在home下做命令是可以不考虑权限</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725215154797.png" alt="image-20240725215154797"></p>
<h2 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2.文件操作命令"></a>2.文件操作命令</h2><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建文件</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>查看文件内容</p>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>查看文件内容，支持翻页比cat更牛逼，可查看内容多的文档</p>
<p>空格翻页</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件</p>
<p>cp -r 路径		复制文件夹</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动文件</p>
<p>文件改名</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725221708073.png" alt="image-20240725221708073"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725222233801.png" alt="image-20240725222233801"></p>
<p>强制删除需要更高的权限，root用户下删除文件会提示询问是否删除，加上-f后直接不弹出</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725222344378.png" alt="image-20240725222344378"></p>
<h2 id="3-查找命令"><a href="#3-查找命令" class="headerlink" title="3.查找命令"></a>3.查找命令</h2><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>查找命令存放的地方</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725222939991.png" alt="image-20240725222939991"></p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>两种搜索方式，同时可以使用通配符</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725224045327.png" alt="image-20240725224045327"></p>
<p>查找文件<img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725224026231.png" alt="image-20240725224026231"></p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>在命令行输出指定内容</p>
<p>可以用双引号“”包围，如果内容比较复杂，有空格或特殊符号的时候</p>
<p>可以用反引号&#96;&#96;包围，被包围的内容会被作为命令执行</p>
<p>任何可以产生结果的东西可以通过重定向符写入到文件中，这里由于echo可以直接将文字打印出来方便理解放在这里</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725225713313.png" alt="image-20240725225713313"></p>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>从后往前看文件的东西</p>
<p>当持续追踪后，可以再开一个命令窗，对文件进行修改，在追踪中的窗口中会一直执行追踪，可以看到现象，ctrl+c结束</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725225924816.png" alt="image-20240725225924816"></p>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>在文件把想要找到的字输出出来</p>
<p>标红的意思是不填内容，搭配管道符使用</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725230531665.png" alt="image-20240725230531665"></p>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>文件内容的统计</p>
<p>默认输出 行数 单词数 字节数</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725230910766.png" alt="image-20240725230910766"></p>
<p>管道符 |	</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725231123443.png" alt="image-20240725231123443"></p>
<h1 id="三-vi-vim文本编辑器"><a href="#三-vi-vim文本编辑器" class="headerlink" title="三.vi\vim文本编辑器"></a>三.vi\vim文本编辑器</h1><p>直接打开是命令模式，并以其作为中转</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725231731343.png" alt="image-20240725231731343"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725232925022.png" alt="image-20240725232925022"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725233106406.png" alt="image-20240725233106406"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240725233213522.png" alt="image-20240725233213522"></p>
<h1 id="三-用户权限"><a href="#三-用户权限" class="headerlink" title="三.用户权限"></a>三.用户权限</h1><h2 id="1-root用户（超级管理员）"><a href="#1-root用户（超级管理员）" class="headerlink" title="1.root用户（超级管理员）"></a>1.root用户（超级管理员）</h2><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731110720419.png" alt="image-20240731110720419"></p>
<p>普通用户只在自己的home是是有权限，例如在根目录下无法创建文件夹</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731111020482.png" alt="image-20240731111020482"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731113525280.png" alt="image-20240731113525280"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731113911326.png" alt="image-20240731113911326"></p>
<h2 id="2-用户、用户组"><a href="#2-用户、用户组" class="headerlink" title="2.用户、用户组"></a>2.用户、用户组</h2><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731114614723.png" alt="image-20240731114614723"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731114715542.png" alt="image-20240731114715542"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731115012411.png" alt="image-20240731115012411"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731121213497.png" alt="image-20240731121213497"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731121258867.png" alt="image-20240731121258867"></p>
<h2 id="3-权限信息"><a href="#3-权限信息" class="headerlink" title="3.权限信息"></a>3.权限信息</h2><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731121409372.png" alt="image-20240731121409372"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731121445715.png" alt="image-20240731121445715"></p>
<h2 id="4-修改权限控制"><a href="#4-修改权限控制" class="headerlink" title="4.修改权限控制"></a>4.修改权限控制</h2><h3 id="修改权限信息"><a href="#修改权限信息" class="headerlink" title="修改权限信息"></a>修改权限信息</h3><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731121633486.png" alt="image-20240731121633486"></p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731121830853.png" alt="image-20240731121830853"></p>
<h3 id="修改所属的用户、用户组"><a href="#修改所属的用户、用户组" class="headerlink" title="修改所属的用户、用户组"></a>修改所属的用户、用户组</h3><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240731122028921.png" alt="image-20240731122028921"></p>
<h1 id="四-快捷键"><a href="#四-快捷键" class="headerlink" title="四.快捷键"></a>四.快捷键</h1><h1 id="五-linux文件管理"><a href="#五-linux文件管理" class="headerlink" title="五.linux文件管理"></a>五.linux文件管理</h1><p>Linux 系统中的 7 种文件类型，包括：普通文件、目录、字符设备文件、块设备文件、符号链接文件、管道文件以及套接字文件。</p>
<h2 id="5-1静态文件与inode"><a href="#5-1静态文件与inode" class="headerlink" title="5.1静态文件与inode"></a>5.1静态文件与inode</h2><p>文件没打开前儿是存放在磁盘里如u盘，他以一种固定的形式进行存放，我们叫他静态文件。</p>
<p>硬盘的最小储存单位是扇区（512字节，0.5kb）。</p>
<p>多个扇区组成块，他是文件存取的最小单位，通常是4kb八个扇区。</p>
<p>由于一个个读取扇区效率太低，而是一次读取一个块</p>
<p>硬盘在分区或格式化是会有俩区域，数据区和inode区</p>
<p>后者存放 inode table （inode表），他存放一个个inode节点，每个文件对应一个inode，相当于一个结构体，记录文件不同信息</p>
<p>在windows下快速格式化是只清理inode区</p>
<p><strong>打开一个文件，系统内部会将这个过程分为三步：</strong></p>
<ol>
<li><p>系统找到这个文件名所对应的 inode 编号；</p>
</li>
<li><p>通过 inode 编号从 inode table 中找到对应的 inode 结构体；</p>
</li>
<li><p>根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。</p>
</li>
</ol>
<p>文件被打开后，内核会申请一段内存（缓存区），他从静态文件变成了动态文件，我们在对其进行操作是对动态文件操作，在结束操作时内核会自动同步到磁盘中。</p>
<h2 id="5-2空洞文件"><a href="#5-2空洞文件" class="headerlink" title="5.2空洞文件"></a>5.2空洞文件</h2><p>使用lseek（）可以修改文件读写位置的偏移量，当偏移字节大于文件字节，会形成空洞文件。</p>
<p>这样做是有好处的，比如在下载文件时，还没下完就已经有内存占用，我们可以开启多个线程从不同位置写入，这样可以提高下载速度。</p>
<h2 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h2><h2 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h2>]]></content>
      <categories>
        <category>Linux</category>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>2-驱动开发知识构建</title>
    <url>/2025/02/15/Linux-driver/2-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\some\place\APlayer.min.css"><script src="http://xxx/aplayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\some\place\Meting.min.js"></script><h2 id="为什么要linux驱动"><a href="#为什么要linux驱动" class="headerlink" title="为什么要linux驱动"></a>为什么要linux驱动</h2><p>首先我们需要明白一点，驱动和开发的关系可以理解为是先有鸡还是再先有蛋，驱动是更底层的是会涉及到内核的，而应用是无法直接操控内核，我们在开发过程中先做一个驱动，驱动提供一个接口可以被应用调用。</p>
<h3 id="1-系统移植"><a href="#1-系统移植" class="headerlink" title="1.系统移植"></a>1.系统移植</h3><p>我们开发一个产品，确定好主控芯片后我们会对他进行系统移植，那么我们知道一个系统的核心也就是linux内核他是一个系统的主体，他实现了整个操作系统的功能，如果对电脑了解的多会只有电脑主板上有一颗bios芯片，他里面保存的程序是电脑上电后执行的第一个程序就是检测硬件以及其他。在linux中也是如此需要一段bootloader代码用于检查各种外设最后引导启动内核，为什么我们的电脑刚买回来插上鼠标键盘就能用，这就是因为他把这些驱动直接放在bootloader中了上电自动就会启动，为什么有的时候像gpu会显示让你更新驱动，所有的外设都需要所谓的驱动才能让其真正的工作起来，驱动更像是一个代码里面写满了所有这个外设的功能。但一个系统光有上面俩个东西还不能正常使用，还需要根文件系统，就好比uboot将镜像文件进行解压，但需要一个地方去接纳解压后的内容。</p>
<p>|</p>
<p>|-uboot编译 –&gt; 生成可执行文件</p>
<p>|-内核编译 –&gt; zimage镜像文件和设备树</p>
<p>|-构建rootfs –&gt; 进行压缩</p>
<p>|-放在一起烧入</p>
<h2 id="驱动实际案例"><a href="#驱动实际案例" class="headerlink" title="驱动实际案例"></a>驱动实际案例</h2><h3 id="helloworld设备"><a href="#helloworld设备" class="headerlink" title="helloworld设备"></a>helloworld设备</h3><h4 id="——撰写驱动（有框架）——编写Makefile——加载驱动——创建设备节点——测试应用"><a href="#——撰写驱动（有框架）——编写Makefile——加载驱动——创建设备节点——测试应用" class="headerlink" title="——撰写驱动（有框架）——编写Makefile——加载驱动——创建设备节点——测试应用"></a>——撰写驱动（有框架）——编写Makefile——加载驱动——创建设备节点——测试应用</h4><h2 id="知识体系构建"><a href="#知识体系构建" class="headerlink" title="知识体系构建"></a>知识体系构建</h2><p>Linux驱动开发<br>├── 驱动基础<br>│   ├── 内核模块（加载&#x2F;卸载）<br>│   ├── 字符设备（file_operations）<br>│   └── 设备号管理（主&#x2F;次设备号）<br>├── 硬件交互<br>│   ├── 设备树（语法、绑定）<br>│   ├── I2C子系统（设备树、驱动）<br>│   ├── SPI子系统（数据传输）<br>│   └── GPIO控制（中断、方向）<br>├── 内核机制<br>│   ├── 中断处理（顶&#x2F;底半部）<br>│   ├── 同步机制（锁、信号量）<br>│   └── 内存管理（DMA、kmalloc）<br>├── 高级框架<br>│   ├── IIO（传感器驱动）<br>│   ├── Input子系统（事件上报）<br>│   └── PWM（脉宽调制）<br>├── 调试与优化<br>│   ├── 工具链（dmesg, i2c-tools）<br>│   ├── 性能优化（DMA、中断合并）<br>│   └── 用户态接口（sysfs、ioctl）<br>└── 开发流程<br>    ├── 硬件分析 → 设备树 → 驱动开发 → 测试验证<br>    └── 扩展知识（电源管理、安全）</p>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>方案一：clion</p>
<p>比较复杂，Linux驱动前期还是用vscode</p>
<p>方案二：vscode</p>
<p>ssh远程连接本地的虚拟机</p>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h4 id="为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装"><a href="#为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装" class="headerlink" title="为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装"></a>为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装</h4><p>这俩句话是贯穿整个Linux系统的真言，在系统开发中我们会发现我们至始至终都是在写文件操控文件，怎么理解呢编译内核模块是将他编程.ko文件，我们实现驱动的挂载也是通过打开文件读取信息再放在内核中</p>
<p>封装，我认为是Linux学起来困难的最主要原因，由于Linux是一个开源系统，全世界的程序员为它增砖添瓦，不用说我们自己写的代码有时会对其逻辑挠头，更何况这个全世界顶尖程序员智慧产物，各种概念会让人摸不清头脑，但归根结底代码的方向永远是——偷懒，就是提高各种效率</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20240907100446027.png" alt="image-20240907100446027"></p>
<h3 id="1-文件I-O"><a href="#1-文件I-O" class="headerlink" title="1.文件I&#x2F;O"></a>1.文件I&#x2F;O</h3><h4 id="1-1linux的内存管理"><a href="#1-1linux的内存管理" class="headerlink" title="1.1linux的内存管理"></a>1.1linux的内存管理</h4><p>硬盘最小的存储单位是<strong>扇区</strong>，每个扇区存储512字节（0.5kb）</p>
<p>文件存取的最小单位是<strong>块</strong>，8个扇区组成一个块（4kb）</p>
<p>操作系统读取硬盘时不会一个扇区一个扇区读这样效率太慢所以都是以块为单位</p>
<p>磁盘在被分区时会有两个区域，一个是数据区一个是inode区（存放inode表）</p>
<p>inode本质上来说是一个结构体，他记录了文件的各种信息，每个inode都有自己的编号，所有的编号存在表里</p>
<p>快速格式化是只删除了inode表</p>
<p>打开一个文件系统有以下三步：系统找到文件名对应的inode编号-&gt;通过编号从表里找到对应的inode结构体-&gt;根据信息确认所在的block读数据</p>
<p>文件没被打开时是静态文件安静呆在磁盘中，被打开时系统会申请一段缓冲区读取到内存中缓存，此时文件叫动态文件，打开后对其进行操作是对动态文件进行操作，直到操作结束系统会将动态文件同步到静态文件</p>
<p>为什么这样设计，磁盘等存储设备以块为单位进行读取，所以有一个字节要修改就得把整个块拿出来再修改，在内存是有地址的这样修改更加方便，同时内存读写原要比磁盘读写快</p>
<h4 id="1-2linux的文件类型"><a href="#1-2linux的文件类型" class="headerlink" title="1.2linux的文件类型"></a>1.2linux的文件类型</h4><p>使用stat命令可以查看文件类型</p>
<p>‘ - ‘：普通文件 ：文本文件、二进制文件</p>
<p>‘ d ‘：目录文件</p>
<p>‘ c ‘：字符设备文件</p>
<p>‘ b ‘：块设备文件</p>
<p>‘ l ‘：符号链接文件</p>
<p>‘ s ‘：套接字文件</p>
<p>‘ p ‘：管道文件  </p>
<h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h3><h4 id="2-1PCB进程控制块"><a href="#2-1PCB进程控制块" class="headerlink" title="2.1PCB进程控制块"></a>2.1PCB进程控制块</h4><h4 id="linux下程序编译"><a href="#linux下程序编译" class="headerlink" title="linux下程序编译"></a>linux下程序编译</h4><p>不同于我们在windows下用ide写c语言，由于ide强大的功能我们编译代码是一站式编译，但在Linux下我们需要清楚了解这其中的过程</p>
<p>Linux中使用的是glibc，C语言的标准库，他提供了&lt;stdio.h&gt;这类头文件</p>
<p>预处理——编译——汇编——链接</p>
<p>注意链接是将依赖链接到一起，将机器码文件（.o）链接成一个可执行的文件，这个文件elf文件格式（通用执行文件）</p>
<p>链接有动态库和静态库之分，静态库可以独立运行而不需要其他依赖，但更占用空间，Linux中默认动态库</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20250102161121916.png" alt="image-20250102161121916"></p>
<h5 id="存储设备文件系统"><a href="#存储设备文件系统" class="headerlink" title="存储设备文件系统"></a>存储设备文件系统</h5><p>我们首先想到的通常是Windows 下的FAT32、NTFS、exFAT 以及Linux 下常用的ext2、ext3 和ext4 的类型格式。</p>
<p>这些文件系统都是为了解决如何高效管理存储器空间的问题而诞生的。</p>
<h5 id="伪文件系统"><a href="#伪文件系统" class="headerlink" title="伪文件系统"></a>伪文件系统</h5><p>Linux 内核还提供了procfs、sysfs 和devfs 等伪文件系统。<br>伪文件系统存在于内存中，通常不占用硬盘空间，它以文件的形式，向用户提供了访问系统内核数据的接口。用户和应用程序可以通过访问这些数据接口，得到系统的信息，而且内核允许用户修改内核的某些参数。</p>
<h5 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h5><p>Linux 内核包含了文件管理子系统组件，它主要实现了虚拟文件系统（Virtual File System，VFS），虚拟文件系统屏蔽了各种硬件上的差异以及具体实现的细节，为所有的硬件设备提供统一的接口，从而达到设备无关性的目的，同时文件管理系统还为应用层提供统一的APi接口。为了使不同的文件系统共存，Linux 内核在用户层与具体文件系统之前增加了虚拟文件系统中间层，它对复杂的系统进行抽象化，对用户提供了统一的文件操作接口。无论是ext2&#x2F;3&#x2F;4、FAT32、NTFS 存储的文件，还是&#x2F;proc、&#x2F;sys 提供的信息还是硬件设备，无论内容是在本地还是网络上，都使用一样的open、read、write 来访问，使得“一切皆文件”的理念被实现，这也正是软件中间层的魅力。</p>
<h2 id="是什么？内核模块"><a href="#是什么？内核模块" class="headerlink" title="是什么？内核模块"></a>是什么？内核模块</h2><h4 id="内核体系结构有：微内核-Micro-Kernel-、宏内核-Monolithic-Kernel-混合内核-HybridKernel-等"><a href="#内核体系结构有：微内核-Micro-Kernel-、宏内核-Monolithic-Kernel-混合内核-HybridKernel-等" class="headerlink" title="内核体系结构有：微内核(Micro Kernel) 、宏内核(Monolithic Kernel) 混合内核(HybridKernel) 等"></a>内核体系结构有：微内核(Micro Kernel) 、宏内核(Monolithic Kernel) 混合内核(HybridKernel) 等</h4><p>1.windows和鸿蒙是微内核，他们的驱动是不被包含到内核中的，你去动驱动是不影响核心功能（ipc、进程管理啥的）</p>
<p>2.linux是宏内核，驱动是要被编到内核中，但在开发中每次都重新编译一边内核不太现实，所以引入内核模块的概念，提供一种动态的能力</p>
<p>3.我们在开发内核模块时，是将其先编译成.o文件，再链接到内核中，也就是说他可以被单独编译但不能独立运行</p>
<h4 id="内核模块经过编译最终形成-ko-为后缀的ELF-文件"><a href="#内核模块经过编译最终形成-ko-为后缀的ELF-文件" class="headerlink" title="内核模块经过编译最终形成.ko 为后缀的ELF 文件"></a>内核模块经过编译最终形成.ko 为后缀的ELF 文件</h4><ul>
<li><input disabled="" type="checkbox"> 1.ELF格式</li>
</ul>
<p>可以使用readelf 工具查看elf 文件的头部详细信息。</p>
<ul>
<li><input disabled="" type="checkbox"> 2.内核模块安装和卸载的过程</li>
<li><input disabled="" type="checkbox"> 3.内核导出符号的过程</li>
</ul>
<h2 id="驱动开发思路"><a href="#驱动开发思路" class="headerlink" title="驱动开发思路"></a>驱动开发思路</h2><ol>
<li><strong>确定设备分类</strong>：<ul>
<li><strong>字符设备</strong>：如传感器、GPIO等需要字节流操作的设备 <a href="https://blog.csdn.net/zengxianyang/article/details/50589214">3</a><a href="https://blog.csdn.net/eustoma/article/details/8163859">7</a>。</li>
<li><strong>块设备</strong>：如硬盘、U盘等需要块数据读写的设备 <a href="https://www.ppmy.cn/news/26705.html">1</a>。</li>
<li><strong>网络设备</strong>：如网卡、WiFi模块等涉及数据包传输的设备 <a href="https://www.elecfans.com/d/2240727.html">8</a>。</li>
</ul>
</li>
<li><strong>硬件总线类型判断</strong>：<ul>
<li><strong>标准总线设备</strong>（如I2C、SPI、PCIe）：优先使用内核提供的总线驱动框架 <a href="https://blog.csdn.net/qq_42208449/article/details/132907862">6</a><a href="https://blog.csdn.net/imho888/article/details/1921242">9</a>。</li>
<li><strong>非总线设备</strong>（如GPIO）：选择字符设备框架，结合内核GPIO子系统API <a href="https://blog.csdn.net/zengxianyang/article/details/50589214">3</a>。</li>
</ul>
</li>
</ol>
<h3 id="Linux驱动框架分类体系"><a href="#Linux驱动框架分类体系" class="headerlink" title="Linux驱动框架分类体系"></a>Linux驱动框架分类体系</h3><hr>
<h4 id="一、基础设备类型框架"><a href="#一、基础设备类型框架" class="headerlink" title="一、基础设备类型框架"></a>一、基础设备类型框架</h4><table>
<thead>
<tr>
<th>框架类型</th>
<th>内核路径</th>
<th>核心结构体</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字符设备驱动</strong></td>
<td>drivers&#x2F;char&#x2F;</td>
<td><code>struct file_operations</code></td>
<td>传感器、GPIO控制</td>
</tr>
<tr>
<td><strong>块设备驱动</strong></td>
<td>drivers&#x2F;block&#x2F;</td>
<td><code>struct block_device_ops</code></td>
<td>SSD、机械硬盘</td>
</tr>
<tr>
<td><strong>网络设备驱动</strong></td>
<td>drivers&#x2F;net&#x2F;</td>
<td><code>struct net_device_ops</code></td>
<td>以太网卡、WiFi模块</td>
</tr>
</tbody></table>
<hr>
<h4 id="二、总线型驱动框架"><a href="#二、总线型驱动框架" class="headerlink" title="二、总线型驱动框架"></a>二、总线型驱动框架</h4><table>
<thead>
<tr>
<th>总线类型</th>
<th>注册接口</th>
<th>匹配机制</th>
<th>硬件示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>I2C总线</strong></td>
<td>i2c_register_driver()</td>
<td><code>of_device_id</code>+设备树</td>
<td>EEPROM、温度传感器</td>
</tr>
<tr>
<td><strong>SPI总线</strong></td>
<td>spi_register_driver()</td>
<td>SPI设备ID匹配</td>
<td>Flash存储器、TFT屏幕</td>
</tr>
<tr>
<td><strong>USB总线</strong></td>
<td>usb_register_driver()</td>
<td>接口类&#x2F;厂商ID</td>
<td>HID设备、USB摄像头</td>
</tr>
<tr>
<td><strong>PCI&#x2F;PCIe总线</strong></td>
<td>pci_register_driver()</td>
<td>PCI厂商&#x2F;设备ID</td>
<td>显卡、高速网卡</td>
</tr>
<tr>
<td><strong>ACPI总线</strong></td>
<td>acpi_bus_register_driver()</td>
<td>ACPI设备路径匹配</td>
<td>电源管理设备</td>
</tr>
</tbody></table>
<hr>
<h4 id="三、子系统级驱动框架"><a href="#三、子系统级驱动框架" class="headerlink" title="三、子系统级驱动框架"></a>三、子系统级驱动框架</h4><table>
<thead>
<tr>
<th>子系统名称</th>
<th>核心组件</th>
<th>关键API</th>
<th>应用案例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>输入子系统</strong></td>
<td>drivers&#x2F;input&#x2F;</td>
<td><code>input_register_device()</code></td>
<td>键盘、触摸屏</td>
</tr>
<tr>
<td><strong>帧缓冲子系统</strong></td>
<td>drivers&#x2F;video&#x2F;</td>
<td><code>fb_ops</code>结构体</td>
<td>LCD控制器驱动</td>
</tr>
<tr>
<td><strong>声音子系统</strong></td>
<td>sound&#x2F;soc&#x2F;</td>
<td><code>snd_soc_component_driver</code></td>
<td>音频编解码器</td>
</tr>
<tr>
<td><strong>DMA引擎框架</strong></td>
<td>drivers&#x2F;dma&#x2F;</td>
<td><code>dma_device</code>结构</td>
<td>高速数据传输</td>
</tr>
<tr>
<td><strong>IIO子系统</strong></td>
<td>drivers&#x2F;iio&#x2F;</td>
<td><code>iio_chan_spec</code>定义</td>
<td>加速度计、光传感器</td>
</tr>
</tbody></table>
<hr>
<h4 id="四、设备树-DT-关联框架"><a href="#四、设备树-DT-关联框架" class="headerlink" title="四、设备树(DT)关联框架"></a>四、设备树(DT)关联框架</h4><table>
<thead>
<tr>
<th>框架类型</th>
<th>设备树节点特征</th>
<th>关键函数</th>
<th>开发优势</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Platform框架</strong></td>
<td>含<code>compatible</code>属性</td>
<td><code>of_match_table</code>匹配</td>
<td>硬件抽象与驱动分离</td>
</tr>
<tr>
<td><strong>GPIO子系统</strong></td>
<td><code>gpio-controller</code>定义</td>
<td><code>gpiod_get()</code>获取引脚</td>
<td>跨平台引脚管理</td>
</tr>
<tr>
<td><strong>Pinctrl子系统</strong></td>
<td><code>pinctrl-0</code>属性定义</td>
<td><code>pinctrl_lookup_state()</code></td>
<td>引脚复用配置自动化</td>
</tr>
<tr>
<td><strong>Clock框架</strong></td>
<td><code>clocks</code>属性链</td>
<td><code>clk_get()</code>获取时钟</td>
<td>统一时钟树管理</td>
</tr>
<tr>
<td><strong>Regulator框架</strong></td>
<td><code>regulator</code>节点</td>
<td><code>regulator_get()</code></td>
<td>电源管理统一接口</td>
</tr>
</tbody></table>
<hr>
<h4 id="五、高级功能框架"><a href="#五、高级功能框架" class="headerlink" title="五、高级功能框架"></a>五、高级功能框架</h4><table>
<thead>
<tr>
<th>框架名称</th>
<th>技术特性</th>
<th>核心机制</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DMA-BUF框架</strong></td>
<td>内存共享机制</td>
<td><code>dma_buf_export()</code></td>
<td>GPU与VPU数据交换</td>
</tr>
<tr>
<td><strong>V4L2框架</strong></td>
<td>视频采集标准</td>
<td><code>video_device</code>注册</td>
<td>摄像头驱动开发</td>
</tr>
<tr>
<td><strong>DRM&#x2F;KMS框架</strong></td>
<td>图形渲染管理</td>
<td><code>drm_driver</code>结构体</td>
<td>现代显卡驱动</td>
</tr>
<tr>
<td><strong>NTB框架</strong></td>
<td>跨节点通信</td>
<td><code>ntb_register_device()</code></td>
<td>服务器多机互联</td>
</tr>
<tr>
<td><strong>RPMSG框架</strong></td>
<td>多核间通信</td>
<td><code>rpmsg_send()</code></td>
<td>SoC异构核通信</td>
</tr>
</tbody></table>
<hr>
<h4 id="六、特殊设备框架"><a href="#六、特殊设备框架" class="headerlink" title="六、特殊设备框架"></a>六、特殊设备框架</h4><table>
<thead>
<tr>
<th>框架类型</th>
<th>设备特征</th>
<th>实现要点</th>
<th>代表驱动</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MISC驱动</strong></td>
<td>主设备号10</td>
<td><code>miscdevice</code>结构体</td>
<td>看门狗、随机数生成器</td>
</tr>
<tr>
<td><strong>UIO框架</strong></td>
<td>用户空间I&#x2F;O</td>
<td><code>uio_info</code>注册</td>
<td>FPGA加速器控制</td>
</tr>
<tr>
<td><strong>HWMON框架</strong></td>
<td>硬件监控</td>
<td><code>hwmon_device_register()</code></td>
<td>温度传感器监控</td>
</tr>
<tr>
<td><strong>LED框架</strong></td>
<td>灯光控制</td>
<td><code>led_classdev_register()</code></td>
<td>LED指示灯控制</td>
</tr>
<tr>
<td><strong>WATCHDOG框架</strong></td>
<td>系统看门狗</td>
<td><code>watchdog_device</code>结构</td>
<td>硬件级系统复位</td>
</tr>
</tbody></table>
<hr>
<h4 id="七、虚拟化驱动框架"><a href="#七、虚拟化驱动框架" class="headerlink" title="七、虚拟化驱动框架"></a>七、虚拟化驱动框架</h4><table>
<thead>
<tr>
<th>框架名称</th>
<th>虚拟化类型</th>
<th>核心接口</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VFIO框架</strong></td>
<td>设备直通</td>
<td><code>vfio_pci_core_register()</code></td>
<td>云计算GPU直通</td>
</tr>
<tr>
<td><strong>Virtio框架</strong></td>
<td>半虚拟化</td>
<td><code>virtio_device_ops</code></td>
<td>虚拟网卡、块设备</td>
</tr>
<tr>
<td><strong>Xen PV驱动</strong></td>
<td>Xen虚拟化</td>
<td><code>xenbus_driver</code>注册</td>
<td>云服务器虚拟设备</td>
</tr>
<tr>
<td><strong>KVM设备模拟</strong></td>
<td>硬件辅助虚拟化</td>
<td><code>kvm_ioctl()</code></td>
<td>嵌入式虚拟化平台</td>
</tr>
</tbody></table>
<h1 id=""><a href="#" class="headerlink" title="***********"></a>***********</h1><h2 id="学习课程安排"><a href="#学习课程安排" class="headerlink" title="学习课程安排"></a>学习课程安排</h2><h3 id="2-内核模块传参与符号共享"><a href="#2-内核模块传参与符号共享" class="headerlink" title="2 内核模块传参与符号共享"></a>2 内核模块传参与符号共享</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Author: Fanxiaominghang 2309200691@qq.com</span><br><span class="line"> * @Date: 2025-02-06 16:11:36</span><br><span class="line"> * @LastEditors: Fanxiaominghang 2309200691@qq.com</span><br><span class="line"> * @LastEditTime: 2025-02-06 22:37:29</span><br><span class="line"> * @FilePath: /nose/study/hello.c</span><br><span class="line"> * @Description: </span><br><span class="line"> */</span><br><span class="line">#include&lt;linux/module.h&gt;</span><br><span class="line">#include&lt;linux/moduleparam.h&gt;</span><br><span class="line"></span><br><span class="line">#define CNT 1</span><br><span class="line">static int cnt=CNT;</span><br><span class="line">static char *fff=&quot;hi,fmh\n&quot;;</span><br><span class="line">static int arr[]=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">static int nums=sizeof(arr)/sizeof(int);</span><br><span class="line">/*变量传参数</span><br><span class="line">直接变量=要改的值</span><br><span class="line">sudo insmod hello.ko cnt=3 fff=fuck arr=444,4,5</span><br><span class="line">在sys/module/hello下会有一个parameters文件夹</span><br><span class="line">*/</span><br><span class="line">module_param(cnt,int,S_IRUGO);</span><br><span class="line">module_param(fff,charp,S_IRUGO);</span><br><span class="line">module_param_array(arr,int,&amp;nums,S_IRUGO);</span><br><span class="line"></span><br><span class="line">/*符号导出</span><br><span class="line">分着插入</span><br><span class="line">有导出时候，会生成一个Module.symvers文件，可以查看导出符号</span><br><span class="line">也可以在/proc/kallsyms下查看内核符号，但需要过滤</span><br><span class="line">在sys/module/hello下会有一个holders文件夹</span><br><span class="line">*/</span><br><span class="line">EXPORT_SYMBOL(fff);</span><br><span class="line"></span><br><span class="line">static int __init hello_init(void)&#123;</span><br><span class="line">    //printk(KERN_INFO &quot;\n&quot;);  </span><br><span class="line">    printk(KERN_INFO &quot;HELLO\n&quot;);</span><br><span class="line">    printk(KERN_INFO &quot;%s&quot;,fff);  </span><br><span class="line">    int i;</span><br><span class="line">    for ( i = 0; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO &quot;%d:%s&quot;,i,fff);</span><br><span class="line">    &#125;</span><br><span class="line">    for ( i = 0; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO &quot;%d&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO &quot;nums:%d\n&quot;,nums);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit hello_exit(void)&#123;</span><br><span class="line">    printk(KERN_INFO &quot;BYE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;fff&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A simple Linux module&quot;);</span><br><span class="line">MODULE_VERSION(&quot;0.1&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">安装头文件</span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ uname -a</span><br><span class="line">Linux fxh-virtual-machine 5.15.0-130-generic #140~20.04.1-Ubuntu SMP Wed Dec 18 21:35:34 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ sudo apt-get install linux-headers-5.15.0-130</span><br><span class="line">[sudo] fxh 的密码： </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">注意，根据正则表达式 &#x27;linux-headers-5.15.0-130&#x27; 选中了 &#x27;linux-headers-5.15.0-130-generic&#x27;</span><br><span class="line">linux-headers-5.15.0-130-generic 已经是最新版 (5.15.0-130.140~20.04.1)。</span><br><span class="line">linux-headers-5.15.0-130-generic 已设置为手动安装。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 186 个软件包未被升级。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">insmod 加载模块</span><br><span class="line">lsmod 查看模块，名字为makefile中的</span><br><span class="line">dmesg 查看内核打印</span><br><span class="line">rmmod 移除模块</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">由于Linux下皆是文件，所以通过文件系统用户可以直接查看</span><br><span class="line">每加载一个模块就会在sys/module/下生成对应的文件夹</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-设备号"><a href="#3-设备号" class="headerlink" title="3 设备号"></a>3 设备号</h3><p>前两节只是简单框架，但在实际开发中我们用户空间是通过设备文件实现操作</p>
<p>在需要文件时设备号就是必须的</p>
<p>我们可以在&#x2F;proc&#x2F;devises查看设备</p>
<p>主设备号对应驱动程序</p>
<h3 id="4驱动基本框架"><a href="#4驱动基本框架" class="headerlink" title="4驱动基本框架"></a>4驱动基本框架</h3><h3 id="5设备树"><a href="#5设备树" class="headerlink" title="5设备树"></a>5设备树</h3><p>基本语法</p>
<p>从此以后 ARM社区就引入了 PowerPC等架构已经采用的设备树 (Flattened Device Tree)，将这些描述板级硬件信息的内容都从 Linux内中分离开来，用一个专属的文件格式来描<br>述，这个专属的文件就叫做设备树，文件扩展名为 .dts。一个 SOC可以作出很多不同的板子，<br>这些不同的板子肯定是有共同的信息，将这些共同的信息提取出来作为一个通用的文件，其他<br>的 .dts文件直接引用这个通用文件即可，这个通用文件就是 .dtsi文件，类似于 C语言中的头文<br>件。一般 .dts描述板级信息 (也就是开发板上有哪些 IIC设备、 SPI设备等 )，，.dtsi描述 SOC级信<br>息 (也就是 SOC有几个 CPU、主频是多少、各个外设控制器信息等 )。<br>这个就是设备树的由来，简而言之就是， Linux内核中 ARM架构下有太多的冗余的垃圾<br>板级信息文件，导致 linus震怒，然后 ARM社区引入了设备树。</p>
<p>因此在 .dts设<br>备树文件中，可以通过“ “#include”来引用 .h、 .dtsi和 .dts文件。只是，我们在编写设备树头文<br>件的时候最好选择 .dtsi后缀。<br>一般 .dtsi文件用于描述 SOC的内部外设信息，比如 CPU架构、主频、外设寄存器地址范<br>围，比如 UART、 IIC等等。 比如 rk3568.dtsi就是描述 RK3568芯片本身的外设信息， 内容如<br>下：</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>4-内核模块传参与符号共享</title>
    <url>/2025/02/15/Linux-driver/4-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E4%BC%A0%E5%8F%82%E4%B8%8E%E7%AC%A6%E5%8F%B7%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\some\place\APlayer.min.css"><script src="http://xxx/aplayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\some\place\Meting.min.js"></script><p>2 内核模块传参与符号共享</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Author: Fanxiaominghang 2309200691@qq.com</span><br><span class="line"> * @Date: 2025-02-06 16:11:36</span><br><span class="line"> * @LastEditors: Fanxiaominghang 2309200691@qq.com</span><br><span class="line"> * @LastEditTime: 2025-02-06 22:37:29</span><br><span class="line"> * @FilePath: /nose/study/hello.c</span><br><span class="line"> * @Description: </span><br><span class="line"> */</span><br><span class="line">#include&lt;linux/module.h&gt;</span><br><span class="line">#include&lt;linux/moduleparam.h&gt;</span><br><span class="line"></span><br><span class="line">#define CNT 1</span><br><span class="line">static int cnt=CNT;</span><br><span class="line">static char *fff=&quot;hi,fmh\n&quot;;</span><br><span class="line">static int arr[]=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">static int nums=sizeof(arr)/sizeof(int);</span><br><span class="line">/*变量传参数</span><br><span class="line">直接变量=要改的值</span><br><span class="line">sudo insmod hello.ko cnt=3 fff=fuck arr=444,4,5</span><br><span class="line">在sys/module/hello下会有一个parameters文件夹</span><br><span class="line">*/</span><br><span class="line">module_param(cnt,int,S_IRUGO);</span><br><span class="line">module_param(fff,charp,S_IRUGO);</span><br><span class="line">module_param_array(arr,int,&amp;nums,S_IRUGO);</span><br><span class="line"></span><br><span class="line">/*符号导出</span><br><span class="line">分着插入</span><br><span class="line">有导出时候，会生成一个Module.symvers文件，可以查看导出符号</span><br><span class="line">也可以在/proc/kallsyms下查看内核符号，但需要过滤</span><br><span class="line">在sys/module/hello下会有一个holders文件夹</span><br><span class="line">*/</span><br><span class="line">EXPORT_SYMBOL(fff);</span><br><span class="line"></span><br><span class="line">static int __init hello_init(void)&#123;</span><br><span class="line">    //printk(KERN_INFO &quot;\n&quot;);  </span><br><span class="line">    printk(KERN_INFO &quot;HELLO\n&quot;);</span><br><span class="line">    printk(KERN_INFO &quot;%s&quot;,fff);  </span><br><span class="line">    int i;</span><br><span class="line">    for ( i = 0; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO &quot;%d:%s&quot;,i,fff);</span><br><span class="line">    &#125;</span><br><span class="line">    for ( i = 0; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO &quot;%d&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO &quot;nums:%d\n&quot;,nums);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit hello_exit(void)&#123;</span><br><span class="line">    printk(KERN_INFO &quot;BYE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;fff&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A simple Linux module&quot;);</span><br><span class="line">MODULE_VERSION(&quot;0.1&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">安装头文件</span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ uname -a</span><br><span class="line">Linux fxh-virtual-machine 5.15.0-130-generic #140~20.04.1-Ubuntu SMP Wed Dec 18 21:35:34 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ sudo apt-get install linux-headers-5.15.0-130</span><br><span class="line">[sudo] fxh 的密码： </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">注意，根据正则表达式 &#x27;linux-headers-5.15.0-130&#x27; 选中了 &#x27;linux-headers-5.15.0-130-generic&#x27;</span><br><span class="line">linux-headers-5.15.0-130-generic 已经是最新版 (5.15.0-130.140~20.04.1)。</span><br><span class="line">linux-headers-5.15.0-130-generic 已设置为手动安装。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 186 个软件包未被升级。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">insmod 加载模块</span><br><span class="line">lsmod 查看模块，名字为makefile中的</span><br><span class="line">dmesg 查看内核打印</span><br><span class="line">rmmod 移除模块</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">由于Linux下皆是文件，所以通过文件系统用户可以直接查看</span><br><span class="line">每加载一个模块就会在sys/module/下生成对应的文件夹</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>3-第一个驱动开发</title>
    <url>/2025/02/15/Linux-driver/3-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\some\place\APlayer.min.css"><script src="http://xxx/aplayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\some\place\Meting.min.js"></script><p>not helloworld ，hellomodulexiandao</p>
<p>1.大致流程可以总结如下：<br>• 实现入口函数xxx_init() 和卸载函数xxx_exit()<br>• 申请设备号register_chrdev_region()<br>• 初始化字符设备，cdev_init 函数、cdev_add 函数<br>• 硬件初始化，如时钟寄存器配置使能，GPIO 设置为输入输出模式等。<br>• 构建file_operation 结构体内容，实现硬件各个相关的操作<br>• 在终端上使用mknod 根据设备号来进行创建设备文件(节点) 或者自动创建(驱动使用<br>class_create 创建设备类、在类的下面device_create 创建设备节点)</p>
<p>2.但我们会发现一个问题简单的驱动会将所有的硬件信息放在代码中，如果修改驱动或二次开发会遇到问题代码重复修改麻烦，所以提出设备驱动模型分层的概念——驱动代码分成设备与驱动，设备负责提供硬件资源而驱动代码负责去使用这些设备提供的硬件资源，并由总线将它们联系起来。</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20250113163712096.png" alt="image-20250113163712096"></p>
<p>• 设备(device) ：挂载在某个总线的物理设备；<br>• 驱动(driver) ：与特定设备相关的软件，负责初始化该设备以提供一些操作该设备的操作方式；<br>• 总线(bus) ：负责管理挂载对应总线的设备以及驱动；<br>• 类(class) ：对于具有相同功能的设备，归结到一种类别，进行分类管理；</p>
<p>3.&#x2F;sys——sysfs 虚拟文件系统</p>
<p>&#x2F;sys&#x2F;bus 目录下的每个子目录都是注册好了的总线类型。这里是设备按照总线类型分层放置的目<br>录结构，每个子目录(总线类型) 下包含两个子目录——devices 和drivers 文件夹；其中devices 下是<br>该总线类型下的所有设备，而这些设备都是符号链接，它们分别指向真正的设备(&#x2F;sys&#x2F;devices&#x2F;下)；<br>如下图bus 下的usb 总线中的device 则是Devices 目录下&#x2F;pci()&#x2F;dev 0:10&#x2F;usb2 的符号链接。而drivers<br>下是所有注册在这个总线上的驱动，每个driver 子目录下是一些可以观察和修改的driver 参数。<br>&#x2F;sys&#x2F;devices 目录下是全局设备结构体系，包含所有被发现的注册在各种总线上的各种物理设备。<br>一般来说，所有的物理设备都按其在总线上的拓扑结构来显示。&#x2F;sys&#x2F;devices 是内核对系统中所有<br>设备的分层次表达模型，也是&#x2F;sys 文件系统管理设备的最重要的目录结构。<br>&#x2F;sys&#x2F;class 目录下则是包含所有注册在kernel 里面的设备类型，这是按照设备功能分类的设备模型，<br>我们知道每种设备都具有自己特定的功能，比如：鼠标的功能是作为人机交互的输入，按照设备<br>功能分类无论它挂载在哪条总线上都是归类到&#x2F;sys&#x2F;class&#x2F;input 下。</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20250113164809397.png" alt="image-20250113164809397"></p>
<p>在设备模型框架下，设备驱动的开发是一件很简单的事情：先分配一个struct device 类型的变量，填充必要的信息后，把它注册到对应总线中；然后创建一个struct device_driver 类型，填充必要的<br>信息后注册。在合适的时机(驱动和设备匹配时)，就调用驱动的probe、release 等回调函数。另外，在实际编程中较少直接使用device 和device_drivere，而是在它们上面加一层封装，比如platform device 。</p>
<h3 id="1-最简单的内核模块"><a href="#1-最简单的内核模块" class="headerlink" title="1  最简单的内核模块"></a>1  最简单的内核模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;linux/module.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    static:Linux太大了，防止命名冲突</span><br><span class="line">    int、void：这是一种标准，在初始化过程中我们更希望通过退出的状态码来了解，在退出中我们更希望释放资源而不是处理错误</span><br><span class="line">    __init、__exit：是宏，标记函数告诉内核只需要只需要调用一次</span><br><span class="line">*/</span><br><span class="line">static int __init hello_init(void)&#123;</span><br><span class="line">    printk(KERN_INFO &quot;HELLO\n&quot;);   //了解一下printk函数，https://blog.csdn.net/wwwlyj123321/article/details/88422640</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit hello_exit(void)&#123;</span><br><span class="line">    printk(KERN_INFO &quot;BYE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;fff&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A simple Linux module&quot;);</span><br><span class="line">MODULE_VERSION(&quot;0.1&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">安装头文件</span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ uname -a</span><br><span class="line">Linux fxh-virtual-machine 5.15.0-130-generic #140~20.04.1-Ubuntu SMP Wed Dec 18 21:35:34 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ sudo apt-get install linux-headers-5.15.0-130</span><br><span class="line">[sudo] fxh 的密码： </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">注意，根据正则表达式 &#x27;linux-headers-5.15.0-130&#x27; 选中了 &#x27;linux-headers-5.15.0-130-generic&#x27;</span><br><span class="line">linux-headers-5.15.0-130-generic 已经是最新版 (5.15.0-130.140~20.04.1)。</span><br><span class="line">linux-headers-5.15.0-130-generic 已设置为手动安装。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 186 个软件包未被升级。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">insmod 加载模块</span><br><span class="line">lsmod 查看模块，名字为makefile中的</span><br><span class="line">dmesg 查看内核打印</span><br><span class="line">remod 移除模块</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">由于Linux下皆是文件，所以通过文件系统用户可以直接查看</span><br><span class="line">每加载一个模块就会在sys/module/下生成对应的文件夹</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动开发-概述</title>
    <url>/2025/02/15/Linux-driver/0-linux_driver/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\some\place\APlayer.min.css"><script src="http://xxx/aplayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\some\place\Meting.min.js"></script><h2 id="知识体系构建"><a href="#知识体系构建" class="headerlink" title="知识体系构建"></a>知识体系构建</h2><p>Linux驱动开发<br>├── 驱动基础<br>│   ├── 内核模块（加载&#x2F;卸载）<br>│   ├── 字符设备（file_operations）<br>│   └── 设备号管理（主&#x2F;次设备号）<br>├── 硬件交互<br>│   ├── 设备树（语法、绑定）<br>│   ├── I2C子系统（设备树、驱动）<br>│   ├── SPI子系统（数据传输）<br>│   └── GPIO控制（中断、方向）<br>├── 内核机制<br>│   ├── 中断处理（顶&#x2F;底半部）<br>│   ├── 同步机制（锁、信号量）<br>│   └── 内存管理（DMA、kmalloc）<br>├── 高级框架<br>│   ├── IIO（传感器驱动）<br>│   ├── Input子系统（事件上报）<br>│   └── PWM（脉宽调制）<br>├── 调试与优化<br>│   ├── 工具链（dmesg, i2c-tools）<br>│   ├── 性能优化（DMA、中断合并）<br>│   └── 用户态接口（sysfs、ioctl）<br>└── 开发流程<br>├── 硬件分析 → 设备树 → 驱动开发 → 测试验证<br>└── 扩展知识（电源管理、安全）</p>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>方案一：clion</p>
<p>比较复杂，Linux驱动前期还是用vscode</p>
<p>方案二：vscode</p>
<p>ssh远程连接本地的虚拟机</p>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h4 id="为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装"><a href="#为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装" class="headerlink" title="为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装"></a>为什么Linux学起来很难——Linux下全tm是文件，封装封装还是封装</h4><p>这俩句话是贯穿整个Linux系统的真言，在系统开发中我们会发现我们至始至终都是在写文件操控文件，怎么理解呢编译内核模块是将他编程.ko文件，我们实现驱动的挂载也是通过打开文件读取信息再放在内核中</p>
<p>封装，我认为是Linux学起来困难的最主要原因，由于Linux是一个开源系统，全世界的程序员为它增砖添瓦，不用说我们自己写的代码有时会对其逻辑挠头，更何况这个全世界顶尖程序员智慧产物，各种概念会让人摸不清头脑，但归根结底代码的方向永远是——偷懒，就是提高各种效率</p>
<h4 id="linux下程序编译"><a href="#linux下程序编译" class="headerlink" title="linux下程序编译"></a>linux下程序编译</h4><p>不同于我们在windows下用ide写c语言，由于ide强大的功能我们编译代码是一站式编译，但在Linux下我们需要清楚了解这其中的过程</p>
<p>Linux中使用的是glibc，C语言的标准库，他提供了&lt;stdio.h&gt;这类头文件</p>
<p>预处理——编译——汇编——链接</p>
<p>注意链接是将依赖链接到一起，将机器码文件（.o）链接成一个可执行的文件，这个文件elf文件格式（通用执行文件）</p>
<p>链接有动态库和静态库之分，静态库可以独立运行而不需要其他依赖，但更占用空间，Linux中默认动态库</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20250102161121916.png" alt="image-20250102161121916"></p>
<h5 id="存储设备文件系统"><a href="#存储设备文件系统" class="headerlink" title="存储设备文件系统"></a>存储设备文件系统</h5><p>我们首先想到的通常是Windows 下的FAT32、NTFS、exFAT 以及Linux 下常用的ext2、ext3 和ext4 的类型格式。</p>
<p>这些文件系统都是为了解决如何高效管理存储器空间的问题而诞生的。</p>
<h5 id="伪文件系统"><a href="#伪文件系统" class="headerlink" title="伪文件系统"></a>伪文件系统</h5><p>Linux 内核还提供了procfs、sysfs 和devfs 等伪文件系统。<br>伪文件系统存在于内存中，通常不占用硬盘空间，它以文件的形式，向用户提供了访问系统内核数据的接口。用户和应用程序可以通过访问这些数据接口，得到系统的信息，而且内核允许用户修改内核的某些参数。</p>
<h5 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h5><p>Linux 内核包含了文件管理子系统组件，它主要实现了虚拟文件系统（Virtual File System，VFS），虚拟文件系统屏蔽了各种硬件上的差异以及具体实现的细节，为所有的硬件设备提供统一的接口，从而达到设备无关性的目的，同时文件管理系统还为应用层提供统一的APi接口。为了使不同的文件系统共存，Linux 内核在用户层与具体文件系统之前增加了虚拟文件系统中间层，它对复杂的系统进行抽象化，对用户提供了统一的文件操作接口。无论是ext2&#x2F;3&#x2F;4、FAT32、NTFS 存储的文件，还是&#x2F;proc、&#x2F;sys 提供的信息还是硬件设备，无论内容是在本地还是网络上，都使用一样的open、read、write 来访问，使得“一切皆文件”的理念被实现，这也正是软件中间层的魅力。</p>
<h2 id="是什么？内核模块"><a href="#是什么？内核模块" class="headerlink" title="是什么？内核模块"></a>是什么？内核模块</h2><h4 id="内核体系结构有：微内核-Micro-Kernel-、宏内核-Monolithic-Kernel-混合内核-HybridKernel-等"><a href="#内核体系结构有：微内核-Micro-Kernel-、宏内核-Monolithic-Kernel-混合内核-HybridKernel-等" class="headerlink" title="内核体系结构有：微内核(Micro Kernel) 、宏内核(Monolithic Kernel) 混合内核(HybridKernel) 等"></a>内核体系结构有：微内核(Micro Kernel) 、宏内核(Monolithic Kernel) 混合内核(HybridKernel) 等</h4><p>1.windows和鸿蒙是微内核，他们的驱动是不被包含到内核中的，你去动驱动是不影响核心功能（ipc、进程管理啥的）</p>
<p>2.linux是宏内核，驱动是要被编到内核中，但在开发中每次都重新编译一边内核不太现实，所以引入内核模块的概念，提供一种动态的能力</p>
<p>3.我们在开发内核模块时，是将其先编译成.o文件，再链接到内核中，也就是说他可以被单独编译但不能独立运行</p>
<h4 id="内核模块经过编译最终形成-ko-为后缀的ELF-文件"><a href="#内核模块经过编译最终形成-ko-为后缀的ELF-文件" class="headerlink" title="内核模块经过编译最终形成.ko 为后缀的ELF 文件"></a>内核模块经过编译最终形成.ko 为后缀的ELF 文件</h4><ul>
<li><input disabled="" type="checkbox"> 1.ELF格式</li>
</ul>
<p>可以使用readelf 工具查看elf 文件的头部详细信息。</p>
<ul>
<li><input disabled="" type="checkbox"> 2.内核模块安装和卸载的过程</li>
<li><input disabled="" type="checkbox"> 3.内核导出符号的过程</li>
</ul>
<h2 id="驱动开发思路"><a href="#驱动开发思路" class="headerlink" title="驱动开发思路"></a>驱动开发思路</h2><ol>
<li><strong>确定设备分类</strong>：<ul>
<li><strong>字符设备</strong>：如传感器、GPIO等需要字节流操作的设备 <a href="https://blog.csdn.net/zengxianyang/article/details/50589214">3</a><a href="https://blog.csdn.net/eustoma/article/details/8163859">7</a>。</li>
<li><strong>块设备</strong>：如硬盘、U盘等需要块数据读写的设备 <a href="https://www.ppmy.cn/news/26705.html">1</a>。</li>
<li><strong>网络设备</strong>：如网卡、WiFi模块等涉及数据包传输的设备 <a href="https://www.elecfans.com/d/2240727.html">8</a>。</li>
</ul>
</li>
<li><strong>硬件总线类型判断</strong>：<ul>
<li><strong>标准总线设备</strong>（如I2C、SPI、PCIe）：优先使用内核提供的总线驱动框架 <a href="https://blog.csdn.net/qq_42208449/article/details/132907862">6</a><a href="https://blog.csdn.net/imho888/article/details/1921242">9</a>。</li>
<li><strong>非总线设备</strong>（如GPIO）：选择字符设备框架，结合内核GPIO子系统API <a href="https://blog.csdn.net/zengxianyang/article/details/50589214">3</a>。</li>
</ul>
</li>
</ol>
<h3 id="Linux驱动框架分类体系（2025版）"><a href="#Linux驱动框架分类体系（2025版）" class="headerlink" title="Linux驱动框架分类体系（2025版）"></a>Linux驱动框架分类体系（2025版）</h3><hr>
<h4 id="一、基础设备类型框架"><a href="#一、基础设备类型框架" class="headerlink" title="一、基础设备类型框架"></a>一、基础设备类型框架</h4><table>
<thead>
<tr>
<th>框架类型</th>
<th>内核路径</th>
<th>核心结构体</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字符设备驱动</strong></td>
<td>drivers&#x2F;char&#x2F;</td>
<td><code>struct file_operations</code></td>
<td>传感器、GPIO控制</td>
</tr>
<tr>
<td><strong>块设备驱动</strong></td>
<td>drivers&#x2F;block&#x2F;</td>
<td><code>struct block_device_ops</code></td>
<td>SSD、机械硬盘</td>
</tr>
<tr>
<td><strong>网络设备驱动</strong></td>
<td>drivers&#x2F;net&#x2F;</td>
<td><code>struct net_device_ops</code></td>
<td>以太网卡、WiFi模块</td>
</tr>
</tbody></table>
<hr>
<h4 id="二、总线型驱动框架"><a href="#二、总线型驱动框架" class="headerlink" title="二、总线型驱动框架"></a>二、总线型驱动框架</h4><table>
<thead>
<tr>
<th>总线类型</th>
<th>注册接口</th>
<th>匹配机制</th>
<th>硬件示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>I2C总线</strong></td>
<td>i2c_register_driver()</td>
<td><code>of_device_id</code>+设备树</td>
<td>EEPROM、温度传感器</td>
</tr>
<tr>
<td><strong>SPI总线</strong></td>
<td>spi_register_driver()</td>
<td>SPI设备ID匹配</td>
<td>Flash存储器、TFT屏幕</td>
</tr>
<tr>
<td><strong>USB总线</strong></td>
<td>usb_register_driver()</td>
<td>接口类&#x2F;厂商ID</td>
<td>HID设备、USB摄像头</td>
</tr>
<tr>
<td><strong>PCI&#x2F;PCIe总线</strong></td>
<td>pci_register_driver()</td>
<td>PCI厂商&#x2F;设备ID</td>
<td>显卡、高速网卡</td>
</tr>
<tr>
<td><strong>ACPI总线</strong></td>
<td>acpi_bus_register_driver()</td>
<td>ACPI设备路径匹配</td>
<td>电源管理设备</td>
</tr>
</tbody></table>
<hr>
<h4 id="三、子系统级驱动框架"><a href="#三、子系统级驱动框架" class="headerlink" title="三、子系统级驱动框架"></a>三、子系统级驱动框架</h4><table>
<thead>
<tr>
<th>子系统名称</th>
<th>核心组件</th>
<th>关键API</th>
<th>应用案例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>输入子系统</strong></td>
<td>drivers&#x2F;input&#x2F;</td>
<td><code>input_register_device()</code></td>
<td>键盘、触摸屏</td>
</tr>
<tr>
<td><strong>帧缓冲子系统</strong></td>
<td>drivers&#x2F;video&#x2F;</td>
<td><code>fb_ops</code>结构体</td>
<td>LCD控制器驱动</td>
</tr>
<tr>
<td><strong>声音子系统</strong></td>
<td>sound&#x2F;soc&#x2F;</td>
<td><code>snd_soc_component_driver</code></td>
<td>音频编解码器</td>
</tr>
<tr>
<td><strong>DMA引擎框架</strong></td>
<td>drivers&#x2F;dma&#x2F;</td>
<td><code>dma_device</code>结构</td>
<td>高速数据传输</td>
</tr>
<tr>
<td><strong>IIO子系统</strong></td>
<td>drivers&#x2F;iio&#x2F;</td>
<td><code>iio_chan_spec</code>定义</td>
<td>加速度计、光传感器</td>
</tr>
</tbody></table>
<hr>
<h4 id="四、设备树-DT-关联框架"><a href="#四、设备树-DT-关联框架" class="headerlink" title="四、设备树(DT)关联框架"></a>四、设备树(DT)关联框架</h4><table>
<thead>
<tr>
<th>框架类型</th>
<th>设备树节点特征</th>
<th>关键函数</th>
<th>开发优势</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Platform框架</strong></td>
<td>含<code>compatible</code>属性</td>
<td><code>of_match_table</code>匹配</td>
<td>硬件抽象与驱动分离</td>
</tr>
<tr>
<td><strong>GPIO子系统</strong></td>
<td><code>gpio-controller</code>定义</td>
<td><code>gpiod_get()</code>获取引脚</td>
<td>跨平台引脚管理</td>
</tr>
<tr>
<td><strong>Pinctrl子系统</strong></td>
<td><code>pinctrl-0</code>属性定义</td>
<td><code>pinctrl_lookup_state()</code></td>
<td>引脚复用配置自动化</td>
</tr>
<tr>
<td><strong>Clock框架</strong></td>
<td><code>clocks</code>属性链</td>
<td><code>clk_get()</code>获取时钟</td>
<td>统一时钟树管理</td>
</tr>
<tr>
<td><strong>Regulator框架</strong></td>
<td><code>regulator</code>节点</td>
<td><code>regulator_get()</code></td>
<td>电源管理统一接口</td>
</tr>
</tbody></table>
<hr>
<h4 id="五、高级功能框架"><a href="#五、高级功能框架" class="headerlink" title="五、高级功能框架"></a>五、高级功能框架</h4><table>
<thead>
<tr>
<th>框架名称</th>
<th>技术特性</th>
<th>核心机制</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DMA-BUF框架</strong></td>
<td>内存共享机制</td>
<td><code>dma_buf_export()</code></td>
<td>GPU与VPU数据交换</td>
</tr>
<tr>
<td><strong>V4L2框架</strong></td>
<td>视频采集标准</td>
<td><code>video_device</code>注册</td>
<td>摄像头驱动开发</td>
</tr>
<tr>
<td><strong>DRM&#x2F;KMS框架</strong></td>
<td>图形渲染管理</td>
<td><code>drm_driver</code>结构体</td>
<td>现代显卡驱动</td>
</tr>
<tr>
<td><strong>NTB框架</strong></td>
<td>跨节点通信</td>
<td><code>ntb_register_device()</code></td>
<td>服务器多机互联</td>
</tr>
<tr>
<td><strong>RPMSG框架</strong></td>
<td>多核间通信</td>
<td><code>rpmsg_send()</code></td>
<td>SoC异构核通信</td>
</tr>
</tbody></table>
<hr>
<h4 id="六、特殊设备框架"><a href="#六、特殊设备框架" class="headerlink" title="六、特殊设备框架"></a>六、特殊设备框架</h4><table>
<thead>
<tr>
<th>框架类型</th>
<th>设备特征</th>
<th>实现要点</th>
<th>代表驱动</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MISC驱动</strong></td>
<td>主设备号10</td>
<td><code>miscdevice</code>结构体</td>
<td>看门狗、随机数生成器</td>
</tr>
<tr>
<td><strong>UIO框架</strong></td>
<td>用户空间I&#x2F;O</td>
<td><code>uio_info</code>注册</td>
<td>FPGA加速器控制</td>
</tr>
<tr>
<td><strong>HWMON框架</strong></td>
<td>硬件监控</td>
<td><code>hwmon_device_register()</code></td>
<td>温度传感器监控</td>
</tr>
<tr>
<td><strong>LED框架</strong></td>
<td>灯光控制</td>
<td><code>led_classdev_register()</code></td>
<td>LED指示灯控制</td>
</tr>
<tr>
<td><strong>WATCHDOG框架</strong></td>
<td>系统看门狗</td>
<td><code>watchdog_device</code>结构</td>
<td>硬件级系统复位</td>
</tr>
</tbody></table>
<hr>
<h4 id="七、虚拟化驱动框架"><a href="#七、虚拟化驱动框架" class="headerlink" title="七、虚拟化驱动框架"></a>七、虚拟化驱动框架</h4><table>
<thead>
<tr>
<th>框架名称</th>
<th>虚拟化类型</th>
<th>核心接口</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VFIO框架</strong></td>
<td>设备直通</td>
<td><code>vfio_pci_core_register()</code></td>
<td>云计算GPU直通</td>
</tr>
<tr>
<td><strong>Virtio框架</strong></td>
<td>半虚拟化</td>
<td><code>virtio_device_ops</code></td>
<td>虚拟网卡、块设备</td>
</tr>
<tr>
<td><strong>Xen PV驱动</strong></td>
<td>Xen虚拟化</td>
<td><code>xenbus_driver</code>注册</td>
<td>云服务器虚拟设备</td>
</tr>
<tr>
<td><strong>KVM设备模拟</strong></td>
<td>硬件辅助虚拟化</td>
<td><code>kvm_ioctl()</code></td>
<td>嵌入式虚拟化平台</td>
</tr>
</tbody></table>
<h4 id="not-helloworld-，hellomodulexiandao"><a href="#not-helloworld-，hellomodulexiandao" class="headerlink" title="not helloworld ，hellomodulexiandao"></a>not helloworld ，hellomodulexiandao</h4><p>1.大致流程可以总结如下：<br>• 实现入口函数xxx_init() 和卸载函数xxx_exit()<br>• 申请设备号register_chrdev_region()<br>• 初始化字符设备，cdev_init 函数、cdev_add 函数<br>• 硬件初始化，如时钟寄存器配置使能，GPIO 设置为输入输出模式等。<br>• 构建file_operation 结构体内容，实现硬件各个相关的操作<br>• 在终端上使用mknod 根据设备号来进行创建设备文件(节点) 或者自动创建(驱动使用<br>class_create 创建设备类、在类的下面device_create 创建设备节点)</p>
<p>2.但我们会发现一个问题简单的驱动会将所有的硬件信息放在代码中，如果修改驱动或二次开发会遇到问题代码重复修改麻烦，所以提出设备驱动模型分层的概念——驱动代码分成设备与驱动，设备负责提供硬件资源而驱动代码负责去使用这些设备提供的硬件资源，并由总线将它们联系起来。</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20250113163712096.png" alt="image-20250113163712096"></p>
<p>• 设备(device) ：挂载在某个总线的物理设备；<br>• 驱动(driver) ：与特定设备相关的软件，负责初始化该设备以提供一些操作该设备的操作方式；<br>• 总线(bus) ：负责管理挂载对应总线的设备以及驱动；<br>• 类(class) ：对于具有相同功能的设备，归结到一种类别，进行分类管理；</p>
<p>3.&#x2F;sys——sysfs 虚拟文件系统</p>
<p>&#x2F;sys&#x2F;bus 目录下的每个子目录都是注册好了的总线类型。这里是设备按照总线类型分层放置的目<br>录结构，每个子目录(总线类型) 下包含两个子目录——devices 和drivers 文件夹；其中devices 下是<br>该总线类型下的所有设备，而这些设备都是符号链接，它们分别指向真正的设备(&#x2F;sys&#x2F;devices&#x2F;下)；<br>如下图bus 下的usb 总线中的device 则是Devices 目录下&#x2F;pci()&#x2F;dev 0:10&#x2F;usb2 的符号链接。而drivers<br>下是所有注册在这个总线上的驱动，每个driver 子目录下是一些可以观察和修改的driver 参数。<br>&#x2F;sys&#x2F;devices 目录下是全局设备结构体系，包含所有被发现的注册在各种总线上的各种物理设备。<br>一般来说，所有的物理设备都按其在总线上的拓扑结构来显示。&#x2F;sys&#x2F;devices 是内核对系统中所有<br>设备的分层次表达模型，也是&#x2F;sys 文件系统管理设备的最重要的目录结构。<br>&#x2F;sys&#x2F;class 目录下则是包含所有注册在kernel 里面的设备类型，这是按照设备功能分类的设备模型，<br>我们知道每种设备都具有自己特定的功能，比如：鼠标的功能是作为人机交互的输入，按照设备<br>功能分类无论它挂载在哪条总线上都是归类到&#x2F;sys&#x2F;class&#x2F;input 下。</p>
<p><img src="C:\Users\23092\AppData\Roaming\Typora\typora-user-images\image-20250113164809397.png" alt="image-20250113164809397"></p>
<p>在设备模型框架下，设备驱动的开发是一件很简单的事情：先分配一个struct device 类型的变量，填充必要的信息后，把它注册到对应总线中；然后创建一个struct device_driver 类型，填充必要的<br>信息后注册。在合适的时机(驱动和设备匹配时)，就调用驱动的probe、release 等回调函数。另外，在实际编程中较少直接使用device 和device_drivere，而是在它们上面加一层封装，比如platform device 。</p>
<p>Linux驱动如何学习和理解，借用大神总结的话，在此记录下，我初次看时感觉很受用，理解的很到位：</p>
<p>上层是文件系统和应用，中层是Linux内核，下层是底层硬件，Linux驱动是介于文件系统和底层硬件之间的，是嵌入到内核中的程序，应用是嵌入到文件系统中的程序，比如Android APP。</p>
<p>对上：Linux设备驱动给上层提供调用的接口；</p>
<p>对中：Linux设备驱动要注册到内核中，标准说法是 挂载在总线上；</p>
<p>对下：直接操作硬件，如GPIO、IIC、SPI、PWM等；</p>
<p>以上三个，Linux内核都提供了大量的接口函数、结构体，其实Linux驱动，就是掌握了这些东西怎么用，适应到自己要写的驱动程序中。</p>
<p>Linux 内核中处处体现面向对象的设计思想，为了统一形形色色的设备，Linux 系统将设备分别抽<br>象为struct cdev, struct block_device,struct net_devce 三个对象，具体的设备都可以包含着三种对象<br>从而继承和三种对象属性和操作，并通过各自的对象添加到相应的驱动模型中，从而进行统一的<br>管理和操作</p>
<p>Linux 内核中将字符设备抽象成一个具体的数据结构(struct cdev), 我们可以理解为字符设备对象，<br>cdev 记录了字符设备的相关信息(设备号、内核对象)，字符设备的打开、读写、关闭等操作接口<br>(file_operations)，在我们想要添加一个字符设备时，就是将这个对象注册到内核中，通过创建一<br>个文件(设备节点) 绑定对象的cdev，当我们对这个文件进行读写操作时，就可以通过虚拟文件<br>系统，在内核中找到这个对象及其操作接口，从而控制设备。</p>
<h1 id=""><a href="#" class="headerlink" title="***********"></a>***********</h1><h2 id="学习课程安排"><a href="#学习课程安排" class="headerlink" title="学习课程安排"></a>学习课程安排</h2><h3 id="1-最简单的内核模块"><a href="#1-最简单的内核模块" class="headerlink" title="1  最简单的内核模块"></a>1  最简单的内核模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;linux/module.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    static:Linux太大了，防止命名冲突</span><br><span class="line">    int、void：这是一种标准，在初始化过程中我们更希望通过退出的状态码来了解，在退出中我们更希望释放资源而不是处理错误</span><br><span class="line">    __init、__exit：是宏，标记函数告诉内核只需要只需要调用一次</span><br><span class="line">*/</span><br><span class="line">static int __init hello_init(void)&#123;</span><br><span class="line">    printk(KERN_INFO &quot;HELLO\n&quot;);   //了解一下printk函数，https://blog.csdn.net/wwwlyj123321/article/details/88422640</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit hello_exit(void)&#123;</span><br><span class="line">    printk(KERN_INFO &quot;BYE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;fff&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A simple Linux module&quot;);</span><br><span class="line">MODULE_VERSION(&quot;0.1&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">安装头文件</span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ uname -a</span><br><span class="line">Linux fxh-virtual-machine 5.15.0-130-generic #140~20.04.1-Ubuntu SMP Wed Dec 18 21:35:34 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ sudo apt-get install linux-headers-5.15.0-130</span><br><span class="line">[sudo] fxh 的密码： </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">注意，根据正则表达式 &#x27;linux-headers-5.15.0-130&#x27; 选中了 &#x27;linux-headers-5.15.0-130-generic&#x27;</span><br><span class="line">linux-headers-5.15.0-130-generic 已经是最新版 (5.15.0-130.140~20.04.1)。</span><br><span class="line">linux-headers-5.15.0-130-generic 已设置为手动安装。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 186 个软件包未被升级。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">insmod 加载模块</span><br><span class="line">lsmod 查看模块，名字为makefile中的</span><br><span class="line">dmesg 查看内核打印</span><br><span class="line">remod 移除模块</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">由于Linux下皆是文件，所以通过文件系统用户可以直接查看</span><br><span class="line">每加载一个模块就会在sys/module/下生成对应的文件夹</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="2-内核模块传参与符号共享"><a href="#2-内核模块传参与符号共享" class="headerlink" title="2 内核模块传参与符号共享"></a>2 内核模块传参与符号共享</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Author: Fanxiaominghang 2309200691@qq.com</span><br><span class="line"> * @Date: 2025-02-06 16:11:36</span><br><span class="line"> * @LastEditors: Fanxiaominghang 2309200691@qq.com</span><br><span class="line"> * @LastEditTime: 2025-02-06 22:37:29</span><br><span class="line"> * @FilePath: /nose/study/hello.c</span><br><span class="line"> * @Description: </span><br><span class="line"> */</span><br><span class="line">#include&lt;linux/module.h&gt;</span><br><span class="line">#include&lt;linux/moduleparam.h&gt;</span><br><span class="line"></span><br><span class="line">#define CNT 1</span><br><span class="line">static int cnt=CNT;</span><br><span class="line">static char *fff=&quot;hi,fmh\n&quot;;</span><br><span class="line">static int arr[]=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">static int nums=sizeof(arr)/sizeof(int);</span><br><span class="line">/*变量传参数</span><br><span class="line">直接变量=要改的值</span><br><span class="line">sudo insmod hello.ko cnt=3 fff=fuck arr=444,4,5</span><br><span class="line">在sys/module/hello下会有一个parameters文件夹</span><br><span class="line">*/</span><br><span class="line">module_param(cnt,int,S_IRUGO);</span><br><span class="line">module_param(fff,charp,S_IRUGO);</span><br><span class="line">module_param_array(arr,int,&amp;nums,S_IRUGO);</span><br><span class="line"></span><br><span class="line">/*符号导出</span><br><span class="line">分着插入</span><br><span class="line">有导出时候，会生成一个Module.symvers文件，可以查看导出符号</span><br><span class="line">也可以在/proc/kallsyms下查看内核符号，但需要过滤</span><br><span class="line">在sys/module/hello下会有一个holders文件夹</span><br><span class="line">*/</span><br><span class="line">EXPORT_SYMBOL(fff);</span><br><span class="line"></span><br><span class="line">static int __init hello_init(void)&#123;</span><br><span class="line">    //printk(KERN_INFO &quot;\n&quot;);  </span><br><span class="line">    printk(KERN_INFO &quot;HELLO\n&quot;);</span><br><span class="line">    printk(KERN_INFO &quot;%s&quot;,fff);  </span><br><span class="line">    int i;</span><br><span class="line">    for ( i = 0; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO &quot;%d:%s&quot;,i,fff);</span><br><span class="line">    &#125;</span><br><span class="line">    for ( i = 0; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO &quot;%d&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO &quot;nums:%d\n&quot;,nums);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit hello_exit(void)&#123;</span><br><span class="line">    printk(KERN_INFO &quot;BYE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;fff&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A simple Linux module&quot;);</span><br><span class="line">MODULE_VERSION(&quot;0.1&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">安装头文件</span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ uname -a</span><br><span class="line">Linux fxh-virtual-machine 5.15.0-130-generic #140~20.04.1-Ubuntu SMP Wed Dec 18 21:35:34 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">fxh@fxh-virtual-machine:~/drive/nose/study$ sudo apt-get install linux-headers-5.15.0-130</span><br><span class="line">[sudo] fxh 的密码： </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">注意，根据正则表达式 &#x27;linux-headers-5.15.0-130&#x27; 选中了 &#x27;linux-headers-5.15.0-130-generic&#x27;</span><br><span class="line">linux-headers-5.15.0-130-generic 已经是最新版 (5.15.0-130.140~20.04.1)。</span><br><span class="line">linux-headers-5.15.0-130-generic 已设置为手动安装。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 186 个软件包未被升级。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">insmod 加载模块</span><br><span class="line">lsmod 查看模块，名字为makefile中的</span><br><span class="line">dmesg 查看内核打印</span><br><span class="line">rmmod 移除模块</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">由于Linux下皆是文件，所以通过文件系统用户可以直接查看</span><br><span class="line">每加载一个模块就会在sys/module/下生成对应的文件夹</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-设备号"><a href="#3-设备号" class="headerlink" title="3 设备号"></a>3 设备号</h3><p>前两节只是简单框架，但在实际开发中我们用户空间是通过设备文件实现操作</p>
<p>在需要文件时设备号就是必须的</p>
<p>我们可以在&#x2F;proc&#x2F;devises查看设备</p>
<p>主设备号对应驱动程序</p>
<h3 id="4驱动基本框架"><a href="#4驱动基本框架" class="headerlink" title="4驱动基本框架"></a>4驱动基本框架</h3><h3 id="5设备树"><a href="#5设备树" class="headerlink" title="5设备树"></a>5设备树</h3><p>基本语法</p>
<p>从此以后 ARM社区就引入了 PowerPC等架构已经采用的设备树 (Flattened Device Tree)，将这些描述板级硬件信息的内容都从 Linux内中分离开来，用一个专属的文件格式来描<br>述，这个专属的文件就叫做设备树，文件扩展名为 .dts。一个 SOC可以作出很多不同的板子，<br>这些不同的板子肯定是有共同的信息，将这些共同的信息提取出来作为一个通用的文件，其他<br>的 .dts文件直接引用这个通用文件即可，这个通用文件就是 .dtsi文件，类似于 C语言中的头文<br>件。一般 .dts描述板级信息 (也就是开发板上有哪些 IIC设备、 SPI设备等 )，，.dtsi描述 SOC级信<br>息 (也就是 SOC有几个 CPU、主频是多少、各个外设控制器信息等 )。<br>这个就是设备树的由来，简而言之就是， Linux内核中 ARM架构下有太多的冗余的垃圾<br>板级信息文件，导致 linus震怒，然后 ARM社区引入了设备树。</p>
<p>因此在 .dts设<br>备树文件中，可以通过“ “#include”来引用 .h、 .dtsi和 .dts文件。只是，我们在编写设备树头文<br>件的时候最好选择 .dtsi后缀。<br>一般 .dtsi文件用于描述 SOC的内部外设信息，比如 CPU架构、主频、外设寄存器地址范<br>围，比如 UART、 IIC等等。 比如 rk3568.dtsi就是描述 RK3568芯片本身的外设信息， 内容如<br>下：</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>驱动开发</category>
        <category>概述</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>驱动开发</tag>
        <tag>概述</tag>
      </tags>
  </entry>
</search>
